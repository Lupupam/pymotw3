# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Doug Hellmann
# This file is distributed under the same license as the PyMOTW-3 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyMOTW-3 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-03-24 20:15-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/asyncio/tasks.rst:3
# 4e3cd1188c8343ae8451b5fdee93d153
msgid "Executing Tasks Concurrently"
msgstr ""

#: ../../source/asyncio/tasks.rst:5
# 498360f741b0408cb354d71c74b5da75
msgid "Tasks are one of the primary ways to interact with the event loop. Tasks wrap coroutines and track when they are complete. Tasks are subclasses of ``Future``, so other coroutines can wait for them and each has a result that can be retrieved after the task completes."
msgstr ""

#: ../../source/asyncio/tasks.rst:12
# d60c2b924416405a975cd978cd2d202a
msgid "Starting a Task"
msgstr ""

#: ../../source/asyncio/tasks.rst:14
# 055af1ec23744ed49930a2d84a9d610d
msgid "To start a task, use ``create_task()`` to create a ``Task`` instance. The resulting task will run as part of the concurrent operations managed by the event loop as long as the loop is running and the coroutine does not return."
msgstr ""

#: ../../source/asyncio/tasks.rst:0
# 6286a55644a14da781b62cb8477a0bd4
msgid "asyncio_create_task.py"
msgstr ""

#: ../../source/asyncio/tasks.rst:23
# 911ec6b308644fb98fbefbb7a2080111
msgid "This example waits for the task to return a result before the ``main()`` function exits."
msgstr ""

#: ../../source/asyncio/tasks.rst:45
# 0898ed4d2eaf4d1b84622c4bd25aa2a5
msgid "Canceling a Task"
msgstr ""

#: ../../source/asyncio/tasks.rst:47
# 7e8bc61cbfb745dc970fc47769174b0b
msgid "By retaining the ``Task`` object returned from ``create_task()``, it is possible to cancel the operation of the task before it completes."
msgstr ""

#: ../../source/asyncio/tasks.rst:0
# e929c54cb3e8422b9f782803d7c83e67
msgid "asyncio_cancel_task.py"
msgstr ""

#: ../../source/asyncio/tasks.rst:55
# 1991c8e9e92748049b3ccd5451561cf1
msgid "This example creates and then cancels a task before starting the event loop. The result is a ``CancelledError`` exception from ``run_until_complete()``."
msgstr ""

#: ../../source/asyncio/tasks.rst:75
# 6fa0bfe055b64c75a033d12bd3df98bd
msgid "If a task is canceled while it is waiting for another concurrent operation, the task is notified of its cancellation by having a ``CancelledError`` exception raised at the point where it is waiting."
msgstr ""

#: ../../source/asyncio/tasks.rst:0
# 4f57aeaf146742f5a3a511e4179dd08e
msgid "asyncio_cancel_task2.py"
msgstr ""

#: ../../source/asyncio/tasks.rst:84
# 7635b7616e954da69404d144fba3df7f
msgid "Catching the exception provides an opportunity to clean up work already done, if necessary."
msgstr ""

#: ../../source/asyncio/tasks.rst:105
# 10fd865271b34ad29195c0732b9a8919
msgid "Creating Tasks from Coroutines"
msgstr ""

#: ../../source/asyncio/tasks.rst:107
# a14aae39dad34bf6b0f7dd0fca55a448
msgid "The ``ensure_future()`` function returns a ``Task`` tied to the execution of a coroutine. That ``Task`` instance can then be passed to other code, which can wait for it without knowing how the original coroutine was constructed or called."
msgstr ""

#: ../../source/asyncio/tasks.rst:0
# 376b416c9aab459099cc7aa8922b9ab7
msgid "asyncio_ensure_future.py"
msgstr ""

#: ../../source/asyncio/tasks.rst:116
# a528a0ccfcfe43aa8feb4743958116e1
msgid "Note that the coroutine given to ``ensure_future()`` is not started until something uses ``await`` to allow it to be executed."
msgstr ""

