# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Doug Hellmann
# This file is distributed under the same license as the PyMOTW-3 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyMOTW-3 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-03-24 20:15-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/asyncio/io_coroutine.rst:3
# 93d522ec353e41ddb9f98353a1a97b04
msgid "Asynchronous I/O Using Coroutines and Streams"
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:5
# 76f04a5cec9d4c32bbbc5d9c139edfdb
msgid "This section examines alternate versions of the two sample programs implementing a simple echo server and client, using coroutines and the ``asyncio`` streams API instead of the protocol and transport class abstractions. The examples operate at a lower abstraction level than the ``Protocol`` API discussed previously, but the events being processed are similar."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:13
# 98053b2dc01c432fbe956899c63f2c53
msgid "Echo Server"
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:15
# 6747ba26f7684033865e5f04327db94b
msgid "The server starts by importing the modules it needs to set up ``asyncio`` and :mod:`logging`, and then it creates an event loop object."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:0
# 45cc360cad084bc4aa1bbb4cf66f18b2
msgid "asyncio_echo_server_coroutine.py"
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:23
# 2177d69d03054e1c99338f069bed9c80
msgid "It then defines a coroutine to handle communication. Each time a client connects, a new instance of the coroutine will be invoked so that within the function the code is only communicating with one client at a time. Python's language runtime manages the state for each coroutine instance, so the application code does not need to manage any extra data structures to track separate clients."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:30
# 194d6eeac8f94afa9d1e9c7a66b1da19
msgid "The arguments to the coroutine are ``StreamReader`` and ``StreamWriter`` instances associated with the new connection. As with the ``Transport``, the client address can be accessed through the writer's method ``get_extra_info()``."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:38
# 127d7fa3523b45f5a72929a30e4cb631
msgid "Although the coroutine is called when the connection is established, there may not be any data to read, yet. To avoid blocking while reading, the coroutine uses ``await`` with the ``read()`` call to allow the event loop to carry on processing other tasks until there is data to read."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:47
# 5c3c8ffb866143e3abce4579c0ed1251
msgid "If the client sends data, it is returned from ``await`` and can be sent back to the client by passing it to the writer. Multiple calls to ``write()`` can be used to buffer outgoing data, and then ``drain()`` is used to flush the results. Since flushing network I/O can block, again ``await`` is used to restore control to the event loop, which monitors the write socket and invokes the writer when it is possible to send more data."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:58
# bf52510d469e48c29a773ccee95fcae3
msgid "If the client has sent no data, ``read()`` returns an empty byte string to indicate that the connection is closed. The server needs to close the socket for writing to the client, and then the coroutine can return to indicate that it is finished."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:66
# 25678a18b9494f12ad42580b31bc7d52
msgid "There are two steps to starting the server. First the application tells the event loop to create a new server object using the coroutine and the hostname and socket on which to listen. The ``start_server()`` method is itself a coroutine, so the results must be processed by the event loop in order to actually start the server. Completing the coroutine produces a ``asyncio.Server`` instance tied to the event loop."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:77
# 6b8128e08577482fb455364fe4f8e220
msgid "Then the event loop needs to be run in order to process events and handle client requests. For a long-running service, the ``run_forever()`` method is the simplest way to do this.  When the event loop is stopped, either by the application code or by signaling the process, the server can be closed to clean up the socket properly, and then the event loop can be closed to finish handling any other coroutines before the program exits."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:89
# ca052840fa5a49e39a90c66253b4d0e8
msgid "Echo Client"
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:91
# 11d101a6761f493a90cd055c9b065d1d
msgid "Constructing a client using a coroutine is very similar to constructing a server.  The code again starts by importing the modules it needs to set up ``asyncio`` and :mod:`logging`, and then creating an event loop object."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:0
# 5f7e5a1189394f079cfdd4df536413f5
msgid "asyncio_echo_client_coroutine.py"
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:100
# e6c8620d99df48568998b00216040291
msgid "The ``echo_client`` coroutine takes arguments telling it where the server is and what messages to send."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:106
# 677db68510ce43eeaad966ffb78acecc
msgid "The coroutine is called when the task starts, but it has no active connection to work with. The first step, therefore, is to have the client establish its own connection. It uses ``await`` to avoid blocking other activity while the ``open_connection()`` coroutine runs."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:115
# 889e0d461f9146cf99d9d3f3fde1e7a1
msgid "The ``open_connection()`` coroutine returns ``StreamReader`` and ``StreamWriter`` instances associated with the new socket. The next step is to use the writer to send data to the server. As in the server, the writer will buffer outgoing data until the socket is ready or ``drain()`` is used to flush the results. Since flushing network I/O can block, again ``await`` is used to restore control to the event loop, which monitors the write socket and invokes the writer when it is possible to send more data."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:127
# c7dad71b46e940e5861ca24bfa6593a6
msgid "Next the client looks for a response from the server by trying to read data until there is nothing left to read. To avoid blocking on an individual ``read()`` call, ``await`` yields control back to the event loop. If the server has sent data, it is logged. If the server has sent no data, ``read()`` returns an empty byte string to indicate that the connection is closed. The client needs to close the socket for sending to the server and then return to indicate that it is finished."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:139
# 80d434d06b6045fa95f9b691842b8dbc
msgid "To start the client, the event loop is called with the coroutine for creating the client. Using ``run_until_complete()`` avoids having an infinite loop in the client program. Unlike in the protocol example, no separate future is needed to signal when the coroutine is finished, because ``echo_client()`` contains all of the client logic itself and it does not return until it has received a response and closed the server connection."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:151
# df3efd150f07459183ec44f95df7cefb
msgid "Output"
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:153
# 2e2a9baa99c34949b062b45eca434c87
msgid "Running the server in one window and the client in another produces the following output."
msgstr ""

#: ../../source/asyncio/io_coroutine.rst:194
# ef02699be6554fab8bed7c8c573e93d9
msgid "Although the client always sends the messages separately, the first two times the client runs the server receives one large message and echoes that back to the client. These results vary in subsequent runs, based on how busy the network is and whether the network buffers are flushed before all of the data is prepared."
msgstr ""

