# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, Doug Hellmann
# This file is distributed under the same license as the PyMOTW-3 package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyMOTW-3 \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-03-24 20:15-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/os/index.rst:3
# 89e06bf13ed64e3e80a727c3811163a8
msgid "os --- Portable access to operating system specific features"
msgstr ""

#: ../../source/os/index.rst:8
# 5e960c2f7a48494aaa1aa03b8518b040
msgid "Portable access to operating system specific features."
msgstr ""

#: ../../source/os/index.rst:10
# b237b1f50bff4a35af23ab801b9332fc
msgid "The ``os`` module provides a wrapper for platform specific modules such as :mod:`posix`, :mod:`nt`, and :mod:`mac`. The API for functions available on all platforms should be the same, so using the ``os`` module offers some measure of portability. Not all functions are available on every platform, however. Many of the process management functions described in this summary are not available for Windows."
msgstr ""

#: ../../source/os/index.rst:17
# 88077e6a6dc44aa2b430b977b876a9fd
msgid "The Python documentation for the ``os`` module is subtitled \"Miscellaneous operating system interfaces\". The module consists mostly of functions for creating and managing running processes or file system content (files and directories), with a few other bits of functionality thrown in besides."
msgstr ""

#: ../../source/os/index.rst:24
# 7d1579562e394af1b859f3127aeb50b8
msgid "Examining the File System Contents"
msgstr ""

#: ../../source/os/index.rst:26
# 276ba14002c84c66a23c6acea98b4730
msgid "To prepare a list of the contents of a directory on the file system, use ``listdir()``."
msgstr ""

#: ../../source/os/index.rst:0
# 7e49096d46f04c259d28b509bd8f5e17
msgid "os_listdir.py"
msgstr ""

#: ../../source/os/index.rst:33
# c1ccc555da2542afb49d83d1d9d7c2f5
msgid "The return value is a list of all of the named members of the directory given. No distinction is made between files, subdirectories, or symlinks."
msgstr ""

#: ../../source/os/index.rst:60
# d5d20da990f24f03a60dbf35d5c7f598
msgid "The function ``walk()`` traverses a directory recursively and for each subdirectory generates a ``tuple`` containing the directory path, any immediate sub-directories of that path, and a list of the names of any files in that directory."
msgstr ""

#: ../../source/os/index.rst:0
# ec8170c96f5b40a19bf7c3d7aa918f57
msgid "os_walk.py"
msgstr ""

#: ../../source/os/index.rst:69
# cf228e1772bd4934bd3bdaaffd6fab20
msgid "This example shows a recursive directory listing."
msgstr ""

#: ../../source/os/index.rst:102
# e73510df52a541d893fb97ffc09fefbd
msgid "If more information is needed than the names of the files, it is likely to be more efficient to use ``scandir()`` than ``listdir()`` because more information is collected in one system call when the directory is scanned."
msgstr ""

#: ../../source/os/index.rst:0
# a7637160fa5c4c72bd811e4eaff4692c
msgid "os_scandir.py"
msgstr ""

#: ../../source/os/index.rst:111
# aef5f201957e46df96409c80b69858b5
msgid "``scandir()`` returns a sequence of ``DirEntry`` instances for the items in the directory. The object has several attributes and methods for accessing metadata about the file."
msgstr ""

#: ../../source/os/index.rst:158
# 9808764e34e143e9ab6624713910015a
msgid "Managing File System Permissions"
msgstr ""

#: ../../source/os/index.rst:160
# 376235ffa35b4253b96defdae8b007cd
msgid "Detailed information about a file can be accessed using ``stat()`` or ``lstat()`` (for checking the status of something that might be a symbolic link)."
msgstr ""

#: ../../source/os/index.rst:0
# 4ca5154219d24848b666f11107f96fba
msgid "os_stat.py"
msgstr ""

#: ../../source/os/index.rst:168
# 560ee8cd869d4dbda63031def3f4d271
msgid "The output will vary depending on how the example code was installed. Try passing different filenames on the command line to ``os_stat.py``."
msgstr ""

#: ../../source/os/index.rst:204
# c4c2224a26cb4758a55b80d334f9342a
msgid "On Unix-like systems, file permissions can be changed using ``chmod()``, passing the mode as an integer. Mode values can be constructed using constants defined in the :mod:`stat` module.  This example toggles the user's execute permission bit:"
msgstr ""

#: ../../source/os/index.rst:0
# 48a29e8426a74248b5cb1d87c791e8b9
msgid "os_stat_chmod.py"
msgstr ""

#: ../../source/os/index.rst:213
# f8f688a939694aa7aaa403b3879c8058
msgid "The script assumes it has the permissions necessary to modify the mode of the file when run."
msgstr ""

#: ../../source/os/index.rst:228
# 14cd69ce9066495c892211b891e0b050
msgid "The function ``access()`` can be used to test the access rights a process has for a file."
msgstr ""

#: ../../source/os/index.rst:0
# e140d7dbf2b9430795c8c5beda9efc1d
msgid "os_access.py"
msgstr ""

#: ../../source/os/index.rst:235
# 92532dd0a5834142ac9a8d2c1155bd8e
msgid "The results will vary depending on how the example code is installed, but the output will be similar to this:"
msgstr ""

#: ../../source/os/index.rst:254
# db4455192046450da14872ad2aa60c2e
msgid "The library documentation for ``access()`` includes two special warnings. First, there is not much sense in calling ``access()`` to test whether a file can be opened before actually calling ``open()`` on it. There is a small, but real, window of time between the two calls during which the permissions on the file could change. The other warning applies mostly to networked file systems that extend the POSIX permission semantics. Some file system types may respond to the POSIX call that a process has permission to access a file, then report a failure when the attempt is made using ``open()`` for some reason not tested via the POSIX call. All in all, it is better to call ``open()`` with the required mode and catch the ``IOError`` raised if there is a problem."
msgstr ""

#: ../../source/os/index.rst:270
# 8d8a3d570f134a96a13f7812ecd6c063
msgid "Creating and Deleting Directories"
msgstr ""

#: ../../source/os/index.rst:272
# 909f3bffadae4276a0827ac92e2f54fe
msgid "There are several functions for working with directories on the file system, including creating, listing contents, and removing them."
msgstr ""

#: ../../source/os/index.rst:0
# f0c28e7448964913a6f3a1d805c6b429
msgid "os_directories.py"
msgstr ""

#: ../../source/os/index.rst:279
# 1ca52c0bc0e84c20a3bc762104ae4f7e
msgid "There are two sets of functions for creating and deleting directories. When creating a new directory with ``mkdir()``, all of the parent directories must already exist. When removing a directory with ``rmdir()``, only the leaf directory (the last part of the path) is actually removed. In contrast, ``makedirs()`` and ``removedirs()`` operate on all of the nodes in the path. ``makedirs()`` will create any parts of the path that do not exist, and ``removedirs()`` will remove all of the parent directories, as long as they are empty."
msgstr ""

#: ../../source/os/index.rst:304
# a861d7cb26bd4668a45e940ed0661fd9
msgid "Working with Symbolic Links"
msgstr ""

#: ../../source/os/index.rst:306
# 1833dde5418c48ac9d240bb6db10ff66
msgid "For platforms and file systems that support them, there are functions for working with symlinks."
msgstr ""

#: ../../source/os/index.rst:0
# fb962678d2eb4e41ad2ad559faba166e
msgid "os_symlinks.py"
msgstr ""

#: ../../source/os/index.rst:313
# 977cc1505caf4705a688577484ffa2de
msgid "Use ``symlink()`` to create a symbolic link and ``readlink()`` for reading it to determine the original file pointed to by the link.  The ``lstat()`` function is like ``stat()``, but operates on symbolic links."
msgstr ""

#: ../../source/os/index.rst:333
# ce6dc7b341c2452eb7a8d53b7883caa8
msgid "Safely Replacing an Existing File"
msgstr ""

#: ../../source/os/index.rst:335
# d6049d0941e6429a8c254eeecb4f15a2
msgid "Replacing or renaming an existing file is not idempotent and may expose applications to race conditions. The ``rename()`` and ``replace()`` functions implement safe algorithms for these actions, using atomic operations on POSIX-compliant systems when possible."
msgstr ""

#: ../../source/os/index.rst:0
# ae3bf29c95f143ffaab442559c875f18
msgid "os_rename_replace.py"
msgstr ""

#: ../../source/os/index.rst:344
# 3e588defbc904fbca5ea0a6671ddc73b
msgid "The ``rename()`` and ``replace()`` functions work across filesystems, most of the time. Renaming a file may fail if it is being moved to a new fileystem or if the destination already exists."
msgstr ""

#: ../../source/os/index.rst:366
# 9377c90815e34fa4bf87ebbf9e093d71
msgid "Detecting and Changing the Process Owner"
msgstr ""

#: ../../source/os/index.rst:368
# b7a21e9a9f4a4b18bd5d49f434be4992
msgid "The next set of functions provided by ``os`` are used for determining and changing the process owner ids. These are most frequently used by authors of daemons or special system programs that need to change permission level rather than running as ``root``. This section does not try to explain all of the intricate details of Unix security, process owners, etc. See the references list at the end of this section for more details."
msgstr ""

#: ../../source/os/index.rst:376
# f308e62540314e73a12283b139e4a7d2
msgid "The following example shows the real and effective user and group information for a process, and then changes the effective values. This is similar to what a daemon would need to do when it starts as root during a system boot, to lower the privilege level and run as a different user."
msgstr ""

#: ../../source/os/index.rst:384
# ec623f79afec4549929cf69a2b4f81e7
msgid "Before running the example, change the ``TEST_GID`` and ``TEST_UID`` values to match a real user defined on the system."
msgstr ""

#: ../../source/os/index.rst:0
# 59c792342369417284d9dfc9ee95e7bc
msgid "os_process_user_example.py"
msgstr ""

#: ../../source/os/index.rst:391
# 13aeb130e3de42d1a75ca455da324f5e
msgid "When run as user with id of 502 and group 502 on OS X, this output is produced:"
msgstr ""

#: ../../source/os/index.rst:413
# faa5a816cb4e4377884b9aad2ce13feb
msgid "The values do not change because when it is not running as root, a process cannot change its effective owner value. Any attempt to set the effective user id or group id to anything other than that of the current user causes an ``OSError``.  Running the same script using ``sudo`` so that it starts out with root privileges is a different story."
msgstr ""

#: ../../source/os/index.rst:445
# b73f3dad988140a09d625958f4d6e94b
msgid "In this case, since it starts as root, the script can change the effective user and group for the process. Once the effective UID is changed, the process is limited to the permissions of that user. Because non-root users cannot change their effective group, the program needs to change the group before changing the user."
msgstr ""

#: ../../source/os/index.rst:452
# ca86a26eadf74e49a05bac7e14a5a4b3
msgid "Managing the Process Environment"
msgstr ""

#: ../../source/os/index.rst:454
# 6c2bb230b71549168e92b89b686acc22
msgid "Another feature of the operating system exposed to a program though the ``os`` module is the environment. Variables set in the environment are visible as strings that can be read through ``os.environ`` or ``getenv()``. Environment variables are commonly used for configuration values such as search paths, file locations, and debug flags. This example shows how to retrieve an environment variable, and pass a value through to a child process."
msgstr ""

#: ../../source/os/index.rst:0
# dd49b1c4ee894acfa36ba52f4f223dc0
msgid "os_environ_example.py"
msgstr ""

#: ../../source/os/index.rst:466
# f3de61e08a4d40ca8f943067162d1984
msgid "The ``os.environ`` object follows the standard Python mapping API for retrieving and setting values. Changes to ``os.environ`` are exported for child processes."
msgstr ""

#: ../../source/os/index.rst:493
# 81b7e9e3718b4b8f83edc26e91ac5ece
msgid "Managing the Process Working Directory"
msgstr ""

#: ../../source/os/index.rst:495
# f02ae78c733a4764aaf4cff2f43e26b9
msgid "Operating systems with hierarchical file systems have a concept of the *current working directory* -- the directory on the file system the process uses as the starting location when files are accessed with relative paths.  The current working directory can be retrieved with ``getcwd()`` and changed with ``chdir()``."
msgstr ""

#: ../../source/os/index.rst:0
# f07fad41e9b44650ba79bec95d0b402b
msgid "os_cwd_example.py"
msgstr ""

#: ../../source/os/index.rst:505
# 10f46d98eeed43cf8489731be6e767e6
msgid "``os.curdir`` and ``os.pardir`` are used to refer to the current and parent directories in a portable manner."
msgstr ""

#: ../../source/os/index.rst:533
# 1471b2e6c4464067aedde84d5aca0b7b
msgid "Running External Commands"
msgstr ""

#: ../../source/os/index.rst:537
# 0f950e80be7f479b956c92565876cfb1
msgid "Many of these functions for working with processes have limited portability. For a more consistent way to work with processes in a platform independent manner, see the :mod:`subprocess` module instead."
msgstr ""

#: ../../source/os/index.rst:542
# ded7582f35804178a9a31bf502d9f985
msgid "The most basic way to run a separate command, without interacting with it at all, is ``system()``. It takes a single string argument, which is the command line to be executed by a sub-process running a shell."
msgstr ""

#: ../../source/os/index.rst:0
# 928d4497deeb42e9b58b69f1324d3419
msgid "os_system_example.py"
msgstr ""

#: ../../source/os/index.rst:550
# cac78561cc9a426cbb0d553b6ca9cd04
msgid "The return value of ``system()`` is the exit value of the shell running the program packed into a 16 bit number, with the high byte the exit status and the low byte the signal number that caused the process to die, or zero."
msgstr ""

#: ../../source/os/index.rst:573
# a255a5ef5a47472c984caef32607b561
msgid "Since the command is passed directly to the shell for processing, it can include shell syntax such as globbing or environment variables."
msgstr ""

#: ../../source/os/index.rst:0
# 45ca8b9db5e04f93b331fae17a4dfe86
msgid "os_system_shell.py"
msgstr ""

#: ../../source/os/index.rst:580
# a07abcfdeabd40f9932ac8e11e3a12ee
msgid "The environment variable ``$TMPDIR`` in this string is expanded when the shell runs the command line."
msgstr ""

#: ../../source/os/index.rst:596
# eaab1bb48c3d4e2da76a4e75763bf585
msgid "Unless the command is explicitly run in the background, the call to ``system()`` blocks until it is complete. Standard input, output, and error from the child process are tied to the appropriate streams owned by the caller by default, but can be redirected using shell syntax."
msgstr ""

#: ../../source/os/index.rst:0
# 89f7af2b27214f468272ad60410388ac
msgid "os_system_background.py"
msgstr ""

#: ../../source/os/index.rst:606
# 901b6c80225b4beb82062a473f9b9afd
msgid "This is getting into shell trickery, though, and there are better ways to accomplish the same thing."
msgstr ""

#: ../../source/os/index.rst:627
# 1207b62ba57b427baf34d3a637442699
msgid "Creating Processes with os.fork()"
msgstr ""

#: ../../source/os/index.rst:629
# 0e06b8f7b33247bf84a3ca9a3be9cfc9
msgid "The POSIX functions ``fork()`` and ``exec()`` (available under Mac OS X, Linux, and other Unix variants) are exposed via the ``os`` module. Entire books have been written about reliably using these functions, so check the library or bookstore for more details than are presented here in this introduction."
msgstr ""

#: ../../source/os/index.rst:635
# ea7da29c620f4622b16a8a744d8d2157
msgid "To create a new process as a clone of the current process, use ``fork()``:"
msgstr ""

#: ../../source/os/index.rst:0
# 541f4d64559d45c59e15e84dc9e2beae
msgid "os_fork_example.py"
msgstr ""

#: ../../source/os/index.rst:642
# 8ef1a348fc0a4e6b8908798f0987af45
msgid "The output will vary based on the state of the system each time the example is run, but it will look something like:"
msgstr ""

#: ../../source/os/index.rst:658
# 90189071833f457c91c266e5ef8b0b2b
msgid "After the fork, there are two processes running the same code. For a program to tell which one it is in, it needs to check the return value of ``fork()``. If the value is ``0``, the current process is the child.  If it is not ``0``, the program is running in the parent process and the return value is the process id of the child process."
msgstr ""

#: ../../source/os/index.rst:0
# 29260188d8c945dbb3924da6a033d214
msgid "os_kill_example.py"
msgstr ""

#: ../../source/os/index.rst:668
# 23b5018ee2f64ac7b16c9dba8992fd1a
msgid "The parent can send signals to the child process using ``kill()`` and the :mod:`signal` module. First, define a signal handler to be invoked when the signal is received.  Then ``fork()``, and in the parent pause a short amount of time before sending a ``USR1`` signal using ``kill()``. This example uses a short pause to give the child process time to set up the signal handler. A real application, would not need (or want) to call ``sleep()``.  In the child, set up the signal handler and go to sleep for a while to give the parent time to send the signal."
msgstr ""

#: ../../source/os/index.rst:696
# 1c9aa51fec824124a2b7092ee68305e8
msgid "A simple way to handle separate behavior in the child process is to check the return value of ``fork()`` and branch. More complex behavior may call for more code separation than a simple branch. In other cases, there may be an existing program that needs to be wrapped. For both of these situations, the ``exec*()`` series of functions can be used to run another program."
msgstr ""

#: ../../source/os/index.rst:0
# b3fdb0285d0c43d9a520c3a35bcdaccb
msgid "os_exec_example.py"
msgstr ""

#: ../../source/os/index.rst:707
# 0e3da2f13c3e4fb2848dae5fd346f6c3
msgid "When a program is run by ``exec()``, the code from that program replaces the code from the existing process."
msgstr ""

#: ../../source/os/index.rst:722
# 7564ec285a7b41fa9c6d49757880cea2
msgid "There are many variations of ``exec()``, depending on the form in which the arguments are available, whether the path and environment of the parent process should be copied to the child, etc.  For all variations, the first argument is a path or filename and the remaining arguments control how that program runs. They are either passed as command line arguments or override the process \"environment\" (see ``os.environ`` and ``os.getenv``).  Refer to the library documentation for complete details."
msgstr ""

#: ../../source/os/index.rst:732
# 18e3c4c5fa92402593c44477d28201a5
msgid "Waiting for Child Processes"
msgstr ""

#: ../../source/os/index.rst:734
# a4e6d91e5e1f4601a43d91eea6c26919
msgid "Many computationally intensive programs use multiple processes to work around the threading limitations of Python and the global interpreter lock. When starting several processes to run separate tasks, the master will need to wait for one or more of them to finish before starting new ones, to avoid overloading the server. There are a few different ways to do that using ``wait()`` and related functions."
msgstr ""

#: ../../source/os/index.rst:741
# 43e1646365dc4b508f8e2efe26f1bf2b
msgid "When it does not matter which child process might exit first, use ``wait()``.  It returns as soon as any child process exits."
msgstr ""

#: ../../source/os/index.rst:0
# 40371af4513f483daa33abd1985af5bd
msgid "os_wait_example.py"
msgstr ""

#: ../../source/os/index.rst:748
# 361217780c6e4772871b6423384f1213
msgid "The return value from ``wait()`` is a tuple containing the process id and exit status combined into a 16-bit value.  The low byte is the number of the signal that killed the process, and the high byte is the status code returned by the process when it exited."
msgstr ""

#: ../../source/os/index.rst:774
# 56d21b6319354140b3368b211c602636
msgid "To wait for a specific process, use ``waitpid()``."
msgstr ""

#: ../../source/os/index.rst:0
# 83750dea06874855a2227c4539f6d233
msgid "os_waitpid_example.py"
msgstr ""

#: ../../source/os/index.rst:780
# fbbc1959ca5b4aa9ab0f93013dc0aa9b
msgid "Pass the process id of the target process, and ``waitpid()`` blocks until that process exits."
msgstr ""

#: ../../source/os/index.rst:804
# 0e683e48ba6e4f88a8247849aa230a54
msgid "``wait3()`` and ``wait4()`` work in a similar manner, but return more detailed information about the child process with the pid, exit status, and resource usage."
msgstr ""

#: ../../source/os/index.rst:809
# 7297064f363948de956b72c3b69482c3
msgid "Spawning New Processes"
msgstr ""

#: ../../source/os/index.rst:811
# 8edcaa0a4254494fbed20969b6cced14
msgid "As a convenience, the ``spawn()`` family of functions handles the ``fork()`` and ``exec()`` in one statement:"
msgstr ""

#: ../../source/os/index.rst:0
# 80c8cd5b215f4f05b77e883920a4f9d8
msgid "os_spawn_example.py"
msgstr ""

#: ../../source/os/index.rst:818
# 84668d522e744960acf0ca94d4267e64
msgid "The first argument is a mode indicating whether or not to wait for the process to finish before returning.  This example waits.  Use ``P_NOWAIT`` to let the other process start, but then resume in the current process."
msgstr ""

#: ../../source/os/index.rst:836
# 87031a08d7d94c70ad058f125ad9b882
msgid "Operating System Error Codes"
msgstr ""

#: ../../source/os/index.rst:838
# 0c21640f6f584a07ab1ca673da436e68
msgid "Error codes defined by the operating system and managed in the :mod:`errno` module can be translated to message strings using ``strerror()``."
msgstr ""

#: ../../source/os/index.rst:0
# 19b2c39123954e61ab66928fd6abcb75
msgid "os_strerror.py"
msgstr ""

#: ../../source/os/index.rst:846
# 30f2eeeea84d4ae988b459a2cb4740ef
msgid "This example shows the messages associated with some error codes that come up frequently."
msgstr ""

#: ../../source/os/index.rst:865
# f7872425a63d488989e81f769397f48f
msgid ":pydoc:`os`"
msgstr ""

#: ../../source/os/index.rst:867
# f4f432c7452f4f7fa7f307da17cc415d
msgid ":ref:`Python 2 to 3 porting notes for os <porting-os>`"
msgstr ""

#: ../../source/os/index.rst:869
# 170400eb83c64b3e8b23fbeb0f3800fc
msgid ":mod:`signal` -- The section on the ``signal`` module goes over signal handling techniques in more detail."
msgstr ""

#: ../../source/os/index.rst:872
# bdccc20783f94871b2ca536f65db2915
msgid ":mod:`subprocess` -- The ``subprocess`` module supersedes ``os.popen()``."
msgstr ""

#: ../../source/os/index.rst:875
# 9981dacd99c043d3b26c6687937535ee
msgid ":mod:`multiprocessing` -- The ``multiprocessing`` module makes working with extra processes easier."
msgstr ""

#: ../../source/os/index.rst:878
# 84ccb3a8649a4e6ca7f6f892d40658cc
msgid ":mod:`tempfile` -- The ``tempfile`` module for working with temporary files."
msgstr ""

#: ../../source/os/index.rst:881
# 081f66efd4184305bb869e7fce903a90
msgid ":ref:`shutil-directory-functions` -- The :mod:`shutil` module also includes functions for working with directory trees."
msgstr ""

#: ../../source/os/index.rst:884
# 1ab1e7ffb1e749fd899c839c350d6ebb
msgid "`Speaking UNIX, Part 8. <http://www.ibm.com/developerworks/aix/library/au-speakingunix8/index.html>`__ -- Learn how UNIX multitasks."
msgstr ""

#: ../../source/os/index.rst:888
# 7ee6f475c2d545bcb2559e1c2bf78c19
msgid "`Standard streams <https://en.wikipedia.org/wiki/Standard_streams>`__ -- For more discussion of stdin, stdout, and stderr."
msgstr ""

#: ../../source/os/index.rst:891
# becb576ef4144866a7e76c1219cb3469
msgid "`Delve into Unix Process Creation <http://www.ibm.com/developerworks/aix/library/au-unixprocess.html>`__ -- Explains the life cycle of a Unix process."
msgstr ""

#: ../../source/os/index.rst:895
# feb4687aeacd43eca8ea05ca5112e3dd
msgid "*Advanced Programming in the UNIX(R) Environment* By W. Richard Stevens and Stephen A. Rago.  Published by Addison-Wesley Professional, 2005.  ISBN-10: 0201433079 -- This book covers working with multiple processes, such as handling signals, closing duplicated file descriptors, etc."
msgstr ""

